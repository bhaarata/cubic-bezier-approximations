<html>
<body>
	<script src="easing.js"></script>
	<script>
	/**
 * BezierEasing - use bezier curve for transition easing function
 * by Gaëtan Renaudeau 2014 – MIT License
 *
 * Credits: is based on Firefox's nsSMILKeySpline.cpp
 * Usage:
 * var spline = BezierEasing(0.25, 0.1, 0.25, 1.0)
 * spline(x) => returns the easing value | x must be in [0, 1] range
 *
 */
(function (definition) {
  if (typeof exports === "object") {
    module.exports = definition();
  } else if (typeof define === 'function' && define.amd) {
    define([], definition);
  } else {
    window.BezierEasing = definition();
  }
}(function () {
  var global = this;

  // These values are established by empiricism with tests (tradeoff: performance VS precision)
  var NEWTON_ITERATIONS = 4;
  var NEWTON_MIN_SLOPE = 0.001;
  var SUBDIVISION_PRECISION = 0.0000001;
  var SUBDIVISION_MAX_ITERATIONS = 10;

  var kSplineTableSize = 11;
  var kSampleStepSize = 1.0 / (kSplineTableSize - 1.0);

  var float32ArraySupported = 'Float32Array' in global;

  function BezierEasing (mX1, mY1, mX2, mY2) {
    // Validate arguments
    if (arguments.length !== 4) {
      throw new Error("BezierEasing requires 4 arguments.");
    }
    for (var i=0; i<4; ++i) {
      if (typeof arguments[i] !== "number" || isNaN(arguments[i]) || !isFinite(arguments[i])) {
        throw new Error("BezierEasing arguments should be integers.");
      } 
    }
    if (mX1 < 0 || mX1 > 1 || mX2 < 0 || mX2 > 1) {
      throw new Error("BezierEasing x values must be in [0, 1] range.");
    }

    var mSampleValues = float32ArraySupported ? new Float32Array(kSplineTableSize) : new Array(kSplineTableSize);
   
    function A (aA1, aA2) { return 1.0 - 3.0 * aA2 + 3.0 * aA1; }
    function B (aA1, aA2) { return 3.0 * aA2 - 6.0 * aA1; }
    function C (aA1)      { return 3.0 * aA1; }
   
    // Returns x(t) given t, x1, and x2, or y(t) given t, y1, and y2.
    function calcBezier (aT, aA1, aA2) {
      return ((A(aA1, aA2)*aT + B(aA1, aA2))*aT + C(aA1))*aT;
    }
   
    // Returns dx/dt given t, x1, and x2, or dy/dt given t, y1, and y2.
    function getSlope (aT, aA1, aA2) {
      return 3.0 * A(aA1, aA2)*aT*aT + 2.0 * B(aA1, aA2) * aT + C(aA1);
    }

    function newtonRaphsonIterate (aX, aGuessT) {
      for (var i = 0; i < NEWTON_ITERATIONS; ++i) {
        var currentSlope = getSlope(aGuessT, mX1, mX2);
        if (currentSlope === 0.0) return aGuessT;
        var currentX = calcBezier(aGuessT, mX1, mX2) - aX;
        aGuessT -= currentX / currentSlope;
      }
      return aGuessT;
    }

    function calcSampleValues () {
      for (var i = 0; i < kSplineTableSize; ++i) {
        mSampleValues[i] = calcBezier(i * kSampleStepSize, mX1, mX2);
      }
    }

    function binarySubdivide (aX, aA, aB) {
      var currentX, currentT, i = 0;
      do {
        currentT = aA + (aB - aA) / 2.0;
        currentX = calcBezier(currentT, mX1, mX2) - aX;
        if (currentX > 0.0) {
          aB = currentT;
        } else {
          aA = currentT;
        }
      } while (Math.abs(currentX) > SUBDIVISION_PRECISION && ++i < SUBDIVISION_MAX_ITERATIONS);
      return currentT;
    }

    function getTForX (aX) {
      var intervalStart = 0.0;
      var currentSample = 1;
      var lastSample = kSplineTableSize - 1;

      for (; currentSample != lastSample && mSampleValues[currentSample] <= aX; ++currentSample) {
        intervalStart += kSampleStepSize;
      }
      --currentSample;

      // Interpolate to provide an initial guess for t
      var dist = (aX - mSampleValues[currentSample]) / (mSampleValues[currentSample+1] - mSampleValues[currentSample]);
      var guessForT = intervalStart + dist * kSampleStepSize;

      var initialSlope = getSlope(guessForT, mX1, mX2);
      if (initialSlope >= NEWTON_MIN_SLOPE) {
        return newtonRaphsonIterate(aX, guessForT);
      } else if (initialSlope === 0.0) {
        return guessForT;
      } else {
        return binarySubdivide(aX, intervalStart, intervalStart + kSampleStepSize);
      }
    }

    var _precomputed = false;
    function precompute() {
      _precomputed = true;
      if (mX1 != mY1 || mX2 != mY2)
        calcSampleValues();
    }

    var f = function (aX) {
      if (!_precomputed) precompute();
      if (mX1 === mY1 && mX2 === mY2) return aX; // linear
      // Because JavaScript number are imprecise, we should guarantee the extremes are right.
      if (aX === 0) return 0;
      if (aX === 1) return 1;
      return calcBezier(getTForX(aX), mY1, mY2);
    };

    f.getControlPoints = function() { return [{ x: mX1, y: mY1 }, { x: mX2, y: mY2 }]; };

    var args = [mX1, mY1, mX2, mY2];
    var str = "BezierEasing("+args+")";
    f.toString = function () { return str; };

    var css = "cubic-bezier("+args+")";
    f.toCSS = function () { return css; };

    return f;
  }

  // CSS mapping
  BezierEasing.css = {
    "ease":        BezierEasing(0.25, 0.1, 0.25, 1.0),
    "linear":      BezierEasing(0.00, 0.0, 1.00, 1.0),
    "ease-in":     BezierEasing(0.42, 0.0, 1.00, 1.0),
    "ease-out":    BezierEasing(0.00, 0.0, 0.58, 1.0),
    "ease-in-out": BezierEasing(0.42, 0.0, 0.58, 1.0)
  };

  return BezierEasing;

}));
</script>
	<script>
	var w = 1000;
	var h = 1000;

	var w2 = w/2;
	var h2 = h/2;

	var canvas = document.createElement('canvas');
	canvas.width = w;
	canvas.height = h;

	document.body.appendChild(canvas);

	var ctx = canvas.getContext('2d');


	var Name = {
		Linear: 'Linear',
		Quad: 'Quadratic',
		Cubic: 'Cubic',
		Quart: 'Quartic',
		Quint: 'Quintic',
		Sine: 'Sinusoidal',
		Expo: 'Exponential',
		Circ: 'Circular',
	};

	var varient = 'Quad', type = 'In';
	var Approx = KKEasing; // CeaserEasing KKEasing

	function draw() {
		ctx.save();
		ctx.clearRect(0, 0, w, h);

		ctx.translate(0, h);
		ctx.scale(1, -1);
		ctx.translate(250, 250);

		ctx.beginPath();
		ctx.moveTo(0, 0);
		ctx.lineTo(w2, 0);
		ctx.stroke();

		ctx.beginPath();
		ctx.moveTo(0, 0);
		ctx.lineTo(0, h2);
		ctx.stroke();

		ctx.strokeStyle = 'rgba(50, 50, 50, 0.5)';
		ctx.beginPath();
		ctx.moveTo(0, 0);
		ctx.lineTo(w2, h2);
		ctx.stroke();




		ctx.lineWidth = 2;
		ctx.strokeStyle = 'blue';
		ctx.beginPath();
		ctx.moveTo(0, 0);
		
		for (var x = 0; x <= w2; x++) {
			var t = x / w2;
			// var k = Tween.CircularIn(t); // Circular
			var k = Tween[Name[varient] + type](t);
			ctx.lineTo(x, k * h2);
		}
		ctx.stroke();

		ctx.globalAlpha = 0.5;
		
		var params = Approx[varient + type];
		// params = [
		// 	1 - params[1], 1 - params[0],
		// 	1 - params[3], 1 - params[2],
		// ];

		// var params = CeaserEasing.QuadIn; KKEasing
		// params = [0.42, 0, 1.0, 1.0];

		// ctx.strokeStyle = 'blue';
		ctx.beginPath();
		ctx.arc(params[0] * w2, params[1] * h2, 10, 0, Math.PI * 2);
		ctx.fill();

		ctx.beginPath();
		ctx.arc(params[2] * w2, params[3] * h2, 10, 0, Math.PI * 2);
		ctx.fill();
		ctx.stroke();

		ctx.beginPath();
		ctx.moveTo(0, 0);
		ctx.lineTo(params[0] * w2, params[1] * h2);
		ctx.stroke();

		ctx.beginPath();
		ctx.moveTo(w2, h2);
		ctx.lineTo(params[2] * w2, params[3] * h2);
		ctx.stroke();


		
		ctx.strokeStyle = 'red';
		ctx.beginPath();
		ctx.moveTo(0, 0);
		// ctx.bezierCurveTo(params[0] * w2, params[1] * h2, params[2] * w2, params[3] * h2, w2, h2);

		ctx.bezierCurveTo(params[0] * w2, params[1] * h2, params[2] * w2, params[3] * h2, w2, h2);
		ctx.stroke();

		ctx.lineWidth = 2;
		ctx.strokeStyle = 'green';
		ctx.beginPath();
		ctx.moveTo(0, 0);
		
		for (var x = 0; x <= w2; x++) {
			var x2 = x / w2;

			var rx = cubicBezier(x2, 0, params[0], params[2], 1);
			var ry = cubicBezier(x2, 0, params[1], params[3], 1);
			
			ctx.lineTo(rx * w2, ry * h2);
		}
		// ctx.stroke();


		var k = Date.now() / 1000 % 2;
		k /= 2;

		var val = Tween[Name[varient] + type](k);

		ctx.fillStyle = 'purple';
		ctx.beginPath();
		ctx.arc(-15, val * w2,10, 0, Math.PI * 2);
		ctx.fill();



		
		rx = BezierEasing(params[0], params[1], params[2], params[3])(k);
		rx = cubicBezier(rx, 0, params[0], params[2], 1);
		ctx.fillStyle = 'blue';
		ctx.beginPath();
		ctx.arc(-55, rx * w2, 10, 0, Math.PI * 2);
		ctx.fill();

		var duration = 20000;
		var epsilon = (1000 / 60 / duration) / 4;

		var bezier = new UnitBezier(params[0], params[1], params[2], params[3]);

		var r2 = bezier.solve(k, epsilon);
		ctx.fillStyle = 'orange';
		ctx.beginPath();
		ctx.arc(-35, r2 * w2, 10, 0, Math.PI * 2);
		ctx.fill();


		ctx.restore();




	}

	function cubicBezier(t, p0, p1, p2, p3) {
		var t2 = 1 - t;
		var cx0 = t2 * t2 * t2;
		var cx1 = 3 * t2 * t2 * t;
		var cx2 = 3 * t2 * t * t;
		var cx3 = t * t * t;


		return cx0 * p0 + cx1 * p1 + cx2 * p2 + cx3 * p3;
	}


	// http://codepen.io/onedayitwillmake/pen/EHDmw
	/**
	* Solver for cubic bezier curve with implicit control points at (0,0) and (1.0, 1.0)
	*/
	function UnitBezier(p1x, p1y, p2x, p2y) {
		// pre-calculate the polynomial coefficients
		// First and last control points are implied to be (0,0) and (1.0, 1.0)
		this.cx = 3.0 * p1x;
		this.bx = 3.0 * (p2x - p1x) - this.cx;
		this.ax = 1.0 - this.cx -this.bx;

		this.cy = 3.0 * p1y;
		this.by = 3.0 * (p2y - p1y) - this.cy;
		this.ay = 1.0 - this.cy - this.by;
	}

	UnitBezier.prototype.epsilon = 1e-6; // Precision  
	UnitBezier.prototype.sampleCurveX = function(t) {
		return ((this.ax * t + this.bx) * t + this.cx) * t;
	}
	UnitBezier.prototype.sampleCurveY = function (t) {
		return ((this.ay * t + this.by) * t + this.cy) * t;
	}
	UnitBezier.prototype.sampleCurveDerivativeX = function (t) {
		return (3.0 * this.ax * t + 2.0 * this.bx) * t + this.cx;
	}

	UnitBezier.prototype.solveCurveX = function (x, epsilon) {
		var t0; 
		var t1;
		var t2;
		var x2;
		var d2;
		var i;

		// First try a few iterations of Newton's method -- normally very fast.
		for (t2 = x, i = 0; i < 8; i++) {
			x2 = this.sampleCurveX(t2) - x;
			if (Math.abs (x2) < epsilon)
				return t2;
			d2 = this.sampleCurveDerivativeX(t2);
			if (Math.abs(d2) < epsilon)
				break;
			t2 = t2 - x2 / d2;
		}

		// No solution found - use bi-section
		t0 = 0.0;
		t1 = 1.0;
		t2 = x;

		if (t2 < t0) return t0;
		if (t2 > t1) return t1;

		while (t0 < t1) {
			x2 = this.sampleCurveX(t2);
			if (Math.abs(x2 - x) < epsilon)
				return t2;
			if (x > x2) t0 = t2;
			else t1 = t2;

			t2 = (t1 - t0) * .5 + t0;
		}

		// Give up
		return t2;
	}

	// Find new T as a function of Y along curve X
	UnitBezier.prototype.solve = function (x, epsilon) {
		return this.sampleCurveY( this.solveCurveX(x, epsilon) );
	}


	function animate() {
		requestAnimationFrame(animate);

		draw();

	}

	animate();


	// KKEasing CeaserEasing
	// QuadraticIn -> 




	</script>
</body>
</html>